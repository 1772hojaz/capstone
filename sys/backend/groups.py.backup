from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm im        result.append(GroupBuyResponse(
            id=gb.id,
            product_id=gb.product_id,
            product_name=product.name,
            product_description=product.description,
            product_image_url=product.image_url,
            unit_price=product.unit_price,
            bulk_price=product.bulk_price,
            unit_price_zig=product.unit_price_zig,
            bulk_price_zig=product.bulk_price_zig,ssion
from sqlalchemy import and_
from pydantic import BaseModel
from typing import List, Optional
from datetime import datetime
from database import get_db
from models import GroupBuy, Product, Contribution, User, Transaction
from auth import verify_token

router = APIRouter()

# Pydantic Models
class GroupBuyCreate(BaseModel):
    product_id: int
    deadline: datetime

class ContributionCreate(BaseModel):
    quantity: int

class ContributionResponse(BaseModel):
    id: int
    user_id: int
    user_email: str
    quantity: int
    contribution_amount: float
    paid_amount: float
    is_fully_paid: bool

    class Config:
        from_attributes = True

class GroupBuyResponse(BaseModel):
    id: int
    product_id: int
    product_name: str
    product_description: Optional[str] = None
    product_image_url: Optional[str]
    unit_price: float
    bulk_price: float
    unit_price_zig: Optional[float] = None
    bulk_price_zig: Optional[float] = None
    moq: int
    savings_factor: float
    creator_id: int
    location_zone: str
    deadline: datetime
    total_quantity: int
    total_contributions: float
    total_paid: float
    status: str
    moq_progress: float
    participants_count: int
    created_at: datetime
    user_quantity: Optional[int] = None  # User's contribution quantity if they joined

    class Config:
        from_attributes = True

# Routes
@router.get("/", response_model=List[GroupBuyResponse])
async def get_group_buys(
    status: Optional[str] = "active",
    location_zone: Optional[str] = None,
    user: User = Depends(verify_token),
    db: Session = Depends(get_db)
):
    """Get group-buys filtered by location zone"""
    query = db.query(GroupBuy)
    
    if status:
        query = query.filter(GroupBuy.status == status)
    
    # Filter by location zone (location-aware)
    if location_zone:
        query = query.filter(GroupBuy.location_zone == location_zone)
    else:
        # Default to user's location zone
        query = query.filter(GroupBuy.location_zone == user.location_zone)
    
    # Filter out expired group-buys
    query = query.filter(GroupBuy.deadline > datetime.utcnow())
    
    group_buys = query.all()
    
    result = []
    for gb in group_buys:
        result.append(GroupBuyResponse(
            id=gb.id,
            product_id=gb.product_id,
            product_name=gb.product.name,
            product_description=gb.product.description,
            product_image_url=gb.product.image_url,
            unit_price=gb.product.unit_price,
            bulk_price=gb.product.bulk_price,
            unit_price_zig=gb.product.unit_price_zig,
            bulk_price_zig=gb.product.bulk_price_zig,
            moq=gb.product.moq,
            savings_factor=gb.product.savings_factor,
            creator_id=gb.creator_id,
            location_zone=gb.location_zone,
            deadline=gb.deadline,
            total_quantity=gb.total_quantity,
            total_contributions=gb.total_contributions,
            total_paid=gb.total_paid,
            status=gb.status,
            moq_progress=gb.moq_progress,
            participants_count=gb.participants_count,
            created_at=gb.created_at
        ))
    
    return result

@router.get("/my-groups", response_model=List[GroupBuyResponse])
async def get_user_groups(
    user: User = Depends(verify_token),
    db: Session = Depends(get_db)
):
    """Get all group-buys the user has joined"""
    # Get user's contributions
    contributions = db.query(Contribution).filter(Contribution.user_id == user.id).all()
    group_ids = [c.group_buy_id for c in contributions]
    
    # Get group-buys
    group_buys = db.query(GroupBuy).filter(GroupBuy.id.in_(group_ids)).all()
    
    result = []
    for group in group_buys:
        product = db.query(Product).filter(Product.id == group.product_id).first()
        participants = db.query(Contribution).filter(Contribution.group_buy_id == group.id).count()
        user_contribution = next((c for c in contributions if c.group_buy_id == group.id), None)
        
        group_data = GroupBuyResponse(
            id=group.id,
            product_id=group.product_id,
            product_name=product.name,
            product_image_url=product.image_url,
            unit_price=product.unit_price,
            bulk_price=product.bulk_price,
            moq=product.moq,
            savings_factor=product.savings_factor,
            creator_id=group.creator_id,
            location_zone=group.location_zone,
            deadline=group.deadline,
            total_quantity=group.total_quantity,
            total_contributions=group.total_contributions,
            total_paid=group.total_paid,
            status=group.status,
            moq_progress=group.moq_progress,
            participants_count=participants,
            created_at=group.created_at
        )
        
        # Add user's quantity as a custom attribute (not in the model, but accessible)
        if user_contribution:
            group_data.user_quantity = user_contribution.quantity
        
        result.append(group_data)
    
    return result

@router.get("/{group_id}", response_model=GroupBuyResponse)
async def get_group_buy(
    group_id: int,
    user: User = Depends(verify_token),
    db: Session = Depends(get_db)
):
    """Get a specific group-buy"""
    gb = db.query(GroupBuy).filter(GroupBuy.id == group_id).first()
    if not gb:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Group-buy not found")
    
    return GroupBuyResponse(
        id=group_buy.id,
        product_id=product.id,
        product_name=product.name,
        product_description=gb.product.description,
        product_description=product.description,
        product_image_url=product.image_url,
        unit_price=gb.product.unit_price,
        bulk_price=gb.product.bulk_price,
        unit_price_zig=product.unit_price_zig,
        bulk_price_zig=product.bulk_price_zig,
        unit_price_zig=product.unit_price_zig,
        bulk_price_zig=product.bulk_price_zig,@router.post("/", response_model=GroupBuyResponse)
async def create_group_buy(
    group_data: GroupBuyCreate,
    user: User = Depends(verify_token),
    db: Session = Depends(get_db)
):
    """Create a new group-buy"""
    # Validate product exists
    product = db.query(Product).filter(Product.id == group_data.product_id).first()
    if not product or not product.is_active:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Product not found or inactive")
    
    # Validate deadline is in the future
    if group_data.deadline <= datetime.utcnow():
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Deadline must be in the future")
    
    # Create group-buy
    new_group = GroupBuy(
        product_id=group_data.product_id,
        creator_id=user.id,
        location_zone=user.location_zone,  # Automatically use creator's location
        deadline=group_data.deadline,
        status="active"
    )
    
    db.add(new_group)
    db.commit()
    db.refresh(new_group)
    
    return GroupBuyResponse(
        id=new_group.id,
        product_id=new_group.product_id,
        product_name=product.name,
        product_image_url=product.image_url,
        unit_price=product.unit_price,
        bulk_price=product.bulk_price,
        moq=product.moq,
        savings_factor=product.savings_factor,
        creator_id=new_group.creator_id,
        location_zone=new_group.location_zone,
        deadline=new_group.deadline,
        total_quantity=new_group.total_quantity,
        total_contributions=new_group.total_contributions,
        total_paid=new_group.total_paid,
        status=new_group.status,
        moq_progress=new_group.moq_progress,
        participants_count=new_group.participants_count,
        created_at=new_group.created_at
    )

@router.post("/{group_id}/join")
async def join_group_buy(
    group_id: int,
    contribution_data: ContributionCreate,
    user: User = Depends(verify_token),
    db: Session = Depends(get_db)
):
    """Join a group-buy"""
    from models import RecommendationEvent
    
    # Get group-buy
    group = db.query(GroupBuy).filter(GroupBuy.id == group_id).first()
    if not group:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Group-buy not found")
    
    if group.status != "active":
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Group-buy is not active")
    
    if group.deadline <= datetime.utcnow():
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Group-buy deadline has passed")
    
    # Check if user already joined
    existing = db.query(Contribution).filter(
        and_(Contribution.group_buy_id == group_id, Contribution.user_id == user.id)
    ).first()
    if existing:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Already joined this group-buy")
    
    # Calculate contribution
    product = group.product
    savings_factor = product.savings_factor
    contribution_amount = contribution_data.quantity * product.bulk_price * (1 - savings_factor)
    upfront_payment = contribution_amount * 0.5  # 50% upfront
    
    # Create contribution
    new_contribution = Contribution(
        group_buy_id=group_id,
        user_id=user.id,
        quantity=contribution_data.quantity,
        contribution_amount=contribution_amount,
        paid_amount=upfront_payment,
        is_fully_paid=False
    )
    
    # Update recommendation event if this came from a recommendation
    rec_event = db.query(RecommendationEvent).filter(
        RecommendationEvent.user_id == user.id,
        RecommendationEvent.group_buy_id == group_id,
        RecommendationEvent.joined == False
    ).order_by(RecommendationEvent.shown_at.desc()).first()
    
    if rec_event:
        rec_event.joined = True
        rec_event.joined_at = datetime.utcnow()
        if not rec_event.clicked:
            rec_event.clicked = True
            rec_event.clicked_at = datetime.utcnow()

    
    # Create transaction
    transaction = Transaction(
        user_id=user.id,
        group_buy_id=group_id,
        product_id=product.id,
        quantity=contribution_data.quantity,
        amount=upfront_payment,
        transaction_type="upfront",
        location_zone=user.location_zone,
        cluster_id=user.cluster_id
    )
    
    # Update group totals
    group.total_quantity += contribution_data.quantity
    group.total_contributions += contribution_amount
    group.total_paid += upfront_payment
    
    db.add(new_contribution)
    db.add(transaction)
    db.commit()
    
    return {
        "message": "Successfully joined group-buy",
        "contribution_amount": contribution_amount,
        "upfront_payment": upfront_payment,
        "remaining": contribution_amount - upfront_payment
    }

@router.get("/{group_id}/contributions", response_model=List[ContributionResponse])
async def get_contributions(
    group_id: int,
    user: User = Depends(verify_token),
    db: Session = Depends(get_db)
):
    """Get all contributions for a group-buy"""
    contributions = db.query(Contribution).filter(Contribution.group_buy_id == group_id).all()
    
    result = []
    for c in contributions:
        result.append(ContributionResponse(
            id=c.id,
            user_id=c.user_id,
            user_email=c.user.email,
            quantity=c.quantity,
            contribution_amount=c.contribution_amount,
            paid_amount=c.paid_amount,
            is_fully_paid=c.is_fully_paid
        ))
    
    return result

@router.post("/{group_id}/pay")
async def make_payment(
    group_id: int,
    user: User = Depends(verify_token),
    db: Session = Depends(get_db)
):
    """Make final payment for group-buy"""
    contribution = db.query(Contribution).filter(
        and_(Contribution.group_buy_id == group_id, Contribution.user_id == user.id)
    ).first()
    
    if not contribution:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Contribution not found")
    
    if contribution.is_fully_paid:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Already fully paid")
    
    remaining = contribution.contribution_amount - contribution.paid_amount
    
    # Record payment
    contribution.paid_amount = contribution.contribution_amount
    contribution.is_fully_paid = True
    
    group = db.query(GroupBuy).filter(GroupBuy.id == group_id).first()
    group.total_paid += remaining
    
    # Create transaction
    transaction = Transaction(
        user_id=user.id,
        group_buy_id=group_id,
        product_id=group.product_id,
        quantity=contribution.quantity,
        amount=remaining,
        transaction_type="final",
        location_zone=user.location_zone,
        cluster_id=user.cluster_id
    )
    
    db.add(transaction)
    db.commit()
    
    return {"message": "Payment completed", "transaction_id": transaction.id}

@router.put("/{group_id}/contribution")
async def update_contribution(
    group_id: int,
    data: ContributionCreate,
    user: User = Depends(verify_token),
    db: Session = Depends(get_db)
):
    """Update user's contribution quantity"""
    contribution = db.query(Contribution).filter(
        and_(Contribution.group_buy_id == group_id, Contribution.user_id == user.id)
    ).first()
    
    if not contribution:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Contribution not found")
    
    group = db.query(GroupBuy).filter(GroupBuy.id == group_id).first()
    product = db.query(Product).filter(Product.id == group.product_id).first()
    
    # Calculate difference
    quantity_diff = data.quantity - contribution.quantity
    if quantity_diff < 0:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST, 
            detail="Cannot decrease quantity below initial order"
        )
    
    # Update contribution
    old_quantity = contribution.quantity
    contribution.quantity = data.quantity
    contribution.contribution_amount = data.quantity * product.bulk_price
    contribution.paid_amount = contribution.contribution_amount * 0.5  # Recalculate 50% upfront
    
    # Update group totals
    group.total_quantity += quantity_diff
    group.total_contributions += quantity_diff * product.bulk_price
    group.total_paid += (quantity_diff * product.bulk_price * 0.5)
    
    db.commit()
    
    return {
        "message": "Contribution updated successfully",
        "old_quantity": old_quantity,
        "new_quantity": data.quantity,
        "quantity_increase": quantity_diff
    }